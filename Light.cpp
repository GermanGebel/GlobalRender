#include "Ray.h"
#include "Geometry.h"
#include "structs.h"

#include <vector>
#include <time.h>
#include <random>

#include "Light.h"


int Light::binarySearch(const std::vector<float> &array, double value) {
    int left = 0, right = array.size();

    while (left + 1 < right) {
        int middle = (left + right) / 2;
        if (array[middle] < value)
            left = middle;
        else
            right = middle;
    }
    return left;
}

// Returns random <double> value from a specified range (by default 0~1) generated by mersenne twister
double Light::randomFromRange(double maximum, double minimum) {
    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_real_distribution<double> randomValue(minimum, maximum);

    return randomValue(generator);
}

// Rejection sampling with the linear interpolation as a sample
bool Light::rejectionSampling(double leftProbability, double rightProbability, double chosenAngle, double leftAngle, double rightAngle) {
    double probabilitiesInterpolation = leftProbability + (rightProbability - leftProbability) / (rightAngle - leftAngle) * (chosenAngle - leftAngle);
    double randomProbabilityForRS = randomFromRange(std::max(leftProbability, rightProbability));

    return (randomProbabilityForRS >= probabilitiesInterpolation);
}

// =============================================================================
// =============================== Light =======================================
// =============================================================================

Light::Light(const Color &ks, std::vector<float> intensityTable, Vec3f normal, float flux) :
        flux_(flux), intensityTable_(intensityTableExtension(intensityTable)), ks_(ks), normal_(normal.normalize()) {

    // Вычисляем интеграл по tempTable
    // это потом источника света
    tabularProbabilities = calculateIntegral();
    float calculated_flux = tabularProbabilities.back() * 2 * M_PI;
    if (flux_ == -1) {
        flux_ = calculated_flux;
    } else {
        for (auto &intensity : intensityTable_) {
            intensity *= flux / calculated_flux;
        }
    }
    srand(time(0));
}

Color Light::getColor() const {
    return ks_;
}

float Light::getFlux() const {
  return flux_;
}

std::vector<float> Light::intensityTableExtension(std::vector<float> intensityTable) {
    // делаем tempTable копией intensityTable но с большей дискритизацией
    // это уменьшит ошибку для расчета общего потока и таблицы яркостей
    std::vector<float> tempTable;
    if (intensityTable.size() == 1) {
        for (int i = 0; i < 90; i++) {
            tempTable.push_back(intensityTable[0]);
        }
    } else {
        int width = 90.0 / (float(intensityTable.size()) - 1.0);
        for (int i = 0; i < intensityTable.size() - 1; i++) {
            float k = (intensityTable[i + 1] - intensityTable[i]) / width;
            tempTable.push_back(intensityTable[i]);
            for (int j = 1; j < int(width); j++) {
                tempTable.push_back(tempTable.back() + k);
            }
        }
        tempTable.push_back(intensityTable.back());
    }
    return tempTable;
}

std::vector<float> Light::calculateIntegral() {
    // Проинтегрировать таблицу интенсивностей и получить общий поток
    // интегрируем по сфере
    float width = 90.0f / float(intensityTable_.size() - 1);
    float angle = 0;
    std::vector<float> integral;
    integral.push_back((intensityTable_[0] + intensityTable_[1]) / 2.0 *
                       (cos(angle * M_PI / 180.0) - cos((angle + width) * M_PI / 180.0)));
    angle += width;
    for (int step = 1; step < intensityTable_.size() - 1; step++) {
        integral.push_back(integral.back() + (intensityTable_[step] + intensityTable_[step + 1]) / 2.0 *
                     (cos(angle * M_PI / 180.0) - cos((angle + width) * M_PI / 180.0)));
        angle += width;
    }
    return integral;
}

Vec3f Light::getDir() {
    //Выбор направления испускаемого луча с учетом нормали и таблицы интенсивности
    float phi = rand() % 360;
    float theta = 0.;

    float randIntens = static_cast<float>(rand()) / (static_cast <float> (RAND_MAX/tabularProbabilities.back()));
    int leftPos = binarySearch(tabularProbabilities, randIntens);

    bool isRejected = true;
    float widht = 90.0 / (tabularProbabilities.size() - 1);
    while (isRejected) {
        // Random theta angle from the local range with uniform probability distribution
        theta = randomFromRange(widht*(leftPos+1), widht * leftPos);

        // Rejection sampling
        isRejected = rejectionSampling(tabularProbabilities[leftPos], tabularProbabilities[leftPos+1], theta, widht * leftPos, widht * (leftPos+1));
    }

    phi = phi * M_PI / 180;
    theta = theta * M_PI / 180;
    float x = sin(theta) * cos(phi);
    float y = sin(theta) * sin(phi);
    float z = cos(theta);

    Vec3f dir{x, y, z};
    Vec3f result;
    result.x = rotationMatrix[0].x * dir.x + rotationMatrix[0].y * dir.y + rotationMatrix[0].z * dir.z;
    result.y = rotationMatrix[1].x * dir.x + rotationMatrix[1].y * dir.y + rotationMatrix[1].z * dir.z;
    result.z = rotationMatrix[2].x * dir.x + rotationMatrix[2].y * dir.y + rotationMatrix[2].z * dir.z;

    return result;
}


// =============================================================================
// =============================== PointLight ==================================
// =============================================================================
PointLight::PointLight(const Color &ks,
                       const std::vector<float> &intensityTable,
                       const Vec3f &origin, const Vec3f &normal, float flux) :
        Light(ks, intensityTable, normal, flux), origin_(origin) {
    rotationMatrix = getRotationMatrix(Vec3f(0, 0, 1), normal_);
}

Vec3f PointLight::getRandomPointOfSurf(){
    return origin_;
};

Ray PointLight::fireRay() {
    Ray newRay;
    newRay.color = ks_;
    newRay.direction = getDir();
    newRay.origin = origin_;
    return newRay;
}

float PointLight::calculateIlluminance(const Vec3f& surfPoint, const Vec3f& surfNormal,const Vec3f& lightPoint) {

    // Расчер освещенност (есть точка источнка, и как он освещает какую-то точку в пространсве
    // E = I/(r*r) * cos(alpha)

    Vec3f direRay = surfPoint - lightPoint;
    float distanse = direRay.length();
    float angle = acos((direRay * surfNormal) / distanse) * 180 / M_PI;

    float step = 90.0 / (intensityTable_.size() - 1);

    int leftPosLumTable = angle / step;
    float illuminance = intensityTable_[leftPosLumTable] + ((intensityTable_[leftPosLumTable + 1] -
                                                             intensityTable_[leftPosLumTable]) / step) * (angle - leftPosLumTable * step);                   //Интерполяция по таблице

    return illuminance * cos(angle * M_PI / 180)/ (distanse * distanse );
}

// =============================================================================
// =============================== RectangleLight ==============================
// =============================================================================

RectangleLight::RectangleLight(const Color &ks,
                               const std::vector<float> &intensityTable,
                               const Vec3f &origin, const Vec3f &normal,
                               const Mesh &mesh, float flux) :
        Light(ks, intensityTable, normal, flux), geometryMesh_(mesh) {
    geometryMesh_.sourceLight_ = this;

    normal_ = mesh.triangles_[0].getNormal(normal_);

    float dS = geometryMesh_.getSurfaceArea(); //mesh.getS();
    float step = M_PI_2 / (intensityTable_.size() - 1);
    for (int i = 0; i < intensityTable_.size() - 1; i++) {
        luminanceTable_.push_back(intensityTable_[i] / (dS * cos(i * step)));
    }
    luminanceTable_.push_back(intensityTable_[intensityTable_.size() - 1] /
                              (dS * cos(89.0 * M_PI / 180.0)));

    rotationMatrix = getRotationMatrix(Vec3f(0, 0, 1),normal_);
}

Vec3f RectangleLight::getRandomPointOfSurf(){
    return geometryMesh_.randomSurfPoint();
};

float RectangleLight::calculateLuminance(const Vec3f &rayDir) {
    Vec3f normal = normal_;
    // Луч гулял по сцене и попал на источник света. Надо узнать испускаемую яркость в данном направлении
    normal = Vec3f(-normal.x, -normal.y, -normal.z);
    float angle = acos((rayDir * normal) / (rayDir.length() * normal.length())) * 180 / M_PI;              ///?????
    if (angle >= 90)
        return 0;

    float step = 90.0 / (luminanceTable_.size() - 1);             //step = 22.5, angle = 50

    int leftPosLumTable = angle / step;
    float luminance = luminanceTable_[leftPosLumTable] +
                      ((luminanceTable_[leftPosLumTable + 1] -
                        luminanceTable_[leftPosLumTable]) / step) *
                      (angle - leftPosLumTable * step);
    return luminance;
}

Ray RectangleLight::fireRay() {
    Ray newRay;
    newRay.color = ks_;
    newRay.direction = getDir();
    newRay.origin = geometryMesh_.randomSurfPoint() +normal_ * 0.00001;
    return newRay;
}

float RectangleLight::calculateIlluminance(const Vec3f& surfPoint, const Vec3f& surfNormal,const Vec3f& lightPoint) {

    // Расчер освещенност (есть точка источнка, и как он освещает какую-то точку в пространсве
    // E = I/(r*r) * cos(alpha)

    Vec3f direRay = surfPoint - lightPoint;
    float distanse = direRay.length();
    float angle = acos((direRay * surfNormal) / distanse) * 180 / M_PI;

    if (angle > 90)                     //Если источник света развернут
        return 0;
    float step = 90.0 / (intensityTable_.size() - 1);

    int leftPosLumTable = angle / step;
    float illuminance = intensityTable_[leftPosLumTable] + ((intensityTable_[leftPosLumTable + 1] -
                                                             intensityTable_[leftPosLumTable]) / step) * (angle - leftPosLumTable * step);                   //Интерполяция по таблице

    return illuminance * cos(angle * M_PI / 180)/ (distanse * distanse );
}
